---
title: "IoT Security"
subtitle: "Home Defense"
image: "/smart-lock-security-system.jpg"
iconName: "Shield"
description: "Event-driven smart locking system with 3-layer authentication. Features sub-300ms cloud latency and autonomous 3-strike lockdown."
stats: "< 300ms Latency / 3-Layer Auth"
tech: ["ESP8266", "Blynk IoT", "C++", "WebSockets", "Hardware Design"]
demoLink: "#"
codeLink: "#"
color: "from-blue-500 to-cyan-600"
publishedAt: "2023-08-20"
---

# IoT Security: Event-Driven Home Defense

**IoT Security** is a multi-layer smart locking system designed for real-time protection. Unlike standard smart locks that rely on slow polling loops, this system uses an **Event-Driven Architecture** to react to physical threats instantlyâ€”locking down the system and alerting the owner within milliseconds.

## âš ï¸ The Problem: The Polling Lag

Conventional IoT devices often "poll" the cloud or sensors every few seconds to save power.
*   **Security Risk:** A 2-second delay is enough for a brute-force entry.
*   **Latency:** Remote unlock commands feel sluggish.
*   **Fragility:** Single-method authentication is easy to bypass.

## ðŸ’¡ The Solution: Interrupt-Driven Logic

We completely removed the polling loop.
*   **Zero Latency:** Physical touches trigger hardware interrupts, waking the processor instantly (Âµs).
*   **Reaction Speed:** Cloud alerts are pushed via **WebSockets**, achieving **< 300ms** latency.
*   **Defense in Depth:** 3 independent authentication layers ensure no single point of failure.

---

## ðŸ›¡ï¸ 3-Layer Authentication

1.  **Biometric:** AS608 Optical Sensor for primary, keyless entry.
2.  **PIN Fallback:** 4x4 Matrix Keypad with salt-hashed PIN storage.
3.  **App Override:** Secure remote unlock via the Blynk IoT dashboard.

---

## ðŸ’» Tech Stack Deep Dive

### Firmware (Embedded C++)
The firmware relies on an **Interrupt-Driven State Machine**. It sleeps in a low-power mode until a specific hardware event (Fingerprint detected) occurs.

```cpp
// Interrupt Service Routine (ISR)
// Triggers IMMEDIATELY on physical touch
void IRAM_ATTR detectFinger() {
    if (systemState == IDLE) {
        // 1. Wake ESP8266
        wifi_fpm_do_wakeup();
        
        // 2. State Transition
        systemState = AUTH_WAIT;
        
        // 3. Push Websocket Alert
        Blynk.virtualWrite(V1, "Motion Detected");
    }
}

// Hardware Attach
attachInterrupt(digitalPinToInterrupt(D2), detectFinger, RISING);
```

### Self-Healing Architecture
To prevent system hacks or hangs:
*   **Watchdog Timers:** Automatically resets the MCU if the main loop hangs for > 1s.
*   **Autonomous Lockdown:** A "3-Strike" rule monitors failed attempts. If triggered, the system hard-locks for 10 minutes and sounds a local alarm, independent of cloud connectivity.

## ðŸš€ Impact

*   **Responsiveness:** Reduced cloud Round-Trip-Time (RTT) from **2s** to **< 300ms**.
*   **Reliability:** Uptime > 99.9% achieved via self-healing firmware.
*   **Peace of Mind:** Real-time sync means the owner knows the door state at all times.
